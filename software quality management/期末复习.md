
# 软件质量管理期末复习
- [软件质量管理期末复习](#软件质量管理期末复习)
- [1 概述](#1-概述)
  - [1.1 软件危机](#11-软件危机)
    - [1.1.1 软件危机 VS. 软件工程](#111-软件危机-vs-软件工程)
  - [1.2 软件项目管理](#12-软件项目管理)
    - [1.2.1 概念](#121-概念)
    - [1.2.2 管理视角](#122-管理视角)
      - [1.2.2.1 广义软件过程](#1221-广义软件过程)
      - [1.2.2.2 生命周期模型与软件过程](#1222-生命周期模型与软件过程)
  - [1.3 软件过程管理](#13-软件过程管理)
- [2 软件过程的历史演变和经典工作](#2-软件过程的历史演变和经典工作)
  - [2.1 软件发展三大阶段](#21-软件发展三大阶段)
    - [2.1.1 软硬件一体化阶段](#211-软硬件一体化阶段)
      - [2.1.1.1 软件完全依附于硬件](#2111-软件完全依附于硬件)
      - [2.1.1.2 软件作坊](#2112-软件作坊)
    - [2.1.2 软件成为独立产品](#212-软件成为独立产品)
    - [2.1.3 网络化和服务化](#213-网络化和服务化)
  - [2.2 当前软件发展现状](#22-当前软件发展现状)
  - [2.3 典型DevOps实践和方法](#23-典型devops实践和方法)
- [3 团队动力学](#3-团队动力学)
  - [3.1 理论前提](#31-理论前提)
    - [3.1.1 软件开发是知识工作](#311-软件开发是知识工作)
    - [3.1.2 知识工作管理](#312-知识工作管理)
    - [3.1.3 领导者激励手段](#313-领导者激励手段)
    - [3.1.4 维持激励水平](#314-维持激励水平)
  - [3.2 自主团队](#32-自主团队)
    - [3.2.1 自主团队的特点](#321-自主团队的特点)
    - [3.2.2 自主团队的外部环境](#322-自主团队的外部环境)
  - [3.3 TSP对自主团队的实现](#33-tsp对自主团队的实现)
    - [3.3.1 典型TSP角色](#331-典型tsp角色)
      - [3.3.1.1　项目组长 TL](#3311项目组长-tl)
      - [3.3.1.2　计划经理](#3312计划经理)
      - [3.3.1.3　开发经理](#3313开发经理)
      - [3.3.1.4 质量经理](#3314-质量经理)
      - [3.3.1.5 过程经理](#3315-过程经理)
      - [3.3.1.6 支持经理](#3316-支持经理)
      - [3.3.1.7 开发人员](#3317-开发人员)
  - [3.4 SCRUM中的角色](#34-scrum中的角色)
    - [3.4.1 产品负责人](#341-产品负责人)
    - [3.4.2 开发团队](#342-开发团队)
    - [3.4.3 Scrum Master](#343-scrum-master)
- [4 估算、计划和跟踪](#4-估算计划和跟踪)
  - [4.1 估算](#41-估算)
    - [4.1.1 估算概述](#411-估算概述)
    - [4.1.2 PSP和PROBE](#412-psp和probe)
      - [4.1.2.1 PROBE](#4121-probe)
      - [4.1.2.2 历史数据的获取——度量](#4122-历史数据的获取度量)
      - [4.1.2.3 PSP时间度量（时间日志）](#4123-psp时间度量时间日志)
      - [4.1.2.4 PSP缺陷度量（缺陷日志）](#4124-psp缺陷度量缺陷日志)
    - [4.1.3 SCRUM和故事点](#413-scrum和故事点)
    - [4.1.4 怎么做估算](#414-怎么做估算)
    - [4.1.5 历史数据的处理](#415-历史数据的处理)
      - [4.1.5.1 简单方法](#4151-简单方法)
      - [4.1.5.2 正态分布法](#4152-正态分布法)
      - [4.1.5.3 对数正态分布](#4153-对数正态分布)
      - [4.1.5.4 三种方法对比](#4154-三种方法对比)
      - [4.1.5.5 相关性](#4155-相关性)
      - [4.1.5.6 显著性](#4156-显著性)
      - [4.1.5.7 极端数据](#4157-极端数据)
  - [4.2 计划和跟踪](#42-计划和跟踪)
    - [4.2.1 团队项目规划](#421-团队项目规划)
      - [4.2.1.1 工作分解结构 WBS：Work Breakdown Structure](#4211-工作分解结构-wbswork-breakdown-structure)
      - [4.2.1.2 范围管理](#4212-范围管理)
      - [4.2.1.3 开发策略与计划](#4213-开发策略与计划)
      - [4.2.1.4 过程框架——生命周期模型](#4214-过程框架生命周期模型)
      - [4.2.1.5 通用计划框架](#4215-通用计划框架)
      - [4.2.1.6 日程计划原理和方法](#4216-日程计划原理和方法)
      - [4.2.1.7 质量计划原理和方法](#4217-质量计划原理和方法)
      - [4.2.1.8 风险计划](#4218-风险计划)
      - [4.2.1.9 计划评审和各方承诺](#4219-计划评审和各方承诺)
    - [4.2.2 团队项目跟踪与管理](#422-团队项目跟踪与管理)
      - [4.2.2.1 项目跟踪意义](#4221-项目跟踪意义)
        - [4.2.2.1.1 挣值管理方法](#42211-挣值管理方法)
        - [4.2.2.1.2 里程碑评审](#42212-里程碑评审)
        - [4.2.2.1.3 其他计划跟踪](#42213-其他计划跟踪)
      - [4.2.2.2 纠偏活动的管理](#4222-纠偏活动的管理)
  - [4.3 项目总结](#43-项目总结)
    - [4.3.1 项目总结的意义](#431-项目总结的意义)
    - [4.3.2 项目总结过程](#432-项目总结过程)
      - [4.3.2.1 基于PMBOK的总结](#4321-基于pmbok的总结)
        - [4.3.2.1.1 范围管理](#43211-范围管理)
        - [4.3.2.1.2 时间管理](#43212-时间管理)
        - [4.3.2.1.3 成本管理](#43213-成本管理)
        - [4.3.2.1.4 质量管理](#43214-质量管理)
        - [4.3.2.1.5 项目人力资源管理](#43215-项目人力资源管理)
        - [4.3.2.1.6 项目沟通](#43216-项目沟通)
        - [4.3.2.1.7 项目风险管理](#43217-项目风险管理)
        - [4.3.2.1.8 采购管理](#43218-采购管理)
        - [4.3.2.1.9 整合管理](#43219-整合管理)
      - [4.3.2.2 TSP项目总结介绍](#4322-tsp项目总结介绍)
        - [4.3.2.2.1 过程数据评审阶段](#43221-过程数据评审阶段)
        - [4.3.2.2.2 人员角色评审](#43222-人员角色评审)
    - [4.3.3 项目总结报告模板](#433-项目总结报告模板)
- [5 质量管理](#5-质量管理)
  - [5.1 质量概念](#51-质量概念)
  - [5.2 PSP质量策略](#52-psp质量策略)
    - [5.2.1 不同缺陷消除方式消除缺陷的效率](#521-不同缺陷消除方式消除缺陷的效率)
      - [5.2.1.1  测试消除缺陷的典型流程](#5211--测试消除缺陷的典型流程)
      - [5.2.1.2 评审发现缺陷典型流程](#5212-评审发现缺陷典型流程)
    - [5.2.2 PSP评审过程质量](#522-psp评审过程质量)
      - [5.2.2.1 质量指标之一 ：Yield](#5221-质量指标之一-yield)
      - [5.2.2.2 质量指标之二 ：A/FR](#5222-质量指标之二-afr)
      - [5.2.2.3 质量指标之三：PQI](#5223-质量指标之三pqi)
      - [5.2.2.4 质量指标之四：Review Rate](#5224-质量指标之四review-rate)
      - [5.2.2.4 质量指标之五：DRL](#5224-质量指标之五drl)
      - [5.2.2.5 评审的其他考虑因素](#5225-评审的其他考虑因素)
    - [5.2.3 PSP设计过程](#523-psp设计过程)
      - [5.2.3.1 质量路径 Quality Journey](#5231-质量路径-quality-journey)
      - [5.2.3.2 设计与质量的关系](#5232-设计与质量的关系)
      - [5.2.3.3 PSP设计过程](#5233-psp设计过程)
    - [5.2.4 PSP设计模板](#524-psp设计模板)
      - [5.2.4.1 操作规格模板（Operational Specification  Template， 简称OST）](#5241-操作规格模板operational-specification--template-简称ost)
      - [5.2.4.2 功能规格模板（Functional Specification  Template， 简称FST）](#5242-功能规格模板functional-specification--template-简称fst)
      - [5.2.4.3 状态规格模板（State Specification  Template，简称SST）](#5243-状态规格模板state-specification--template简称sst)
      - [5.2.4.4 逻辑规格模板（Logical Specification  Template，简称LST](#5244-逻辑规格模板logical-specification--template简称lst)
      - [5.2.4.5 UML常用图](#5245-uml常用图)
      - [5.2.4.6 UML与PSP设计模板的关系](#5246-uml与psp设计模板的关系)
      - [5.2.4.7 设计的层次](#5247-设计的层次)
        - [5.2.4.7.1 PSP模板](#52471-psp模板)
    - [5.2.5 设计验证方法](#525-设计验证方法)
      - [5.2.5.1 状态机验证](#5251-状态机验证)
      - [5.2.5.2 符号化执行验证](#5252-符号化执行验证)
      - [5.2.5.3 执行表验证](#5253-执行表验证)
      - [5.2.5.4 跟踪表验证](#5254-跟踪表验证)
      - [5.2.5.5 正确性检验](#5255-正确性检验)
- [6 团队工程开发](#6-团队工程开发)
  - [6.1 需求开发](#61-需求开发)
  - [6.2 团队设计](#62-团队设计)
  - [6.3 实现策略](#63-实现策略)
  - [6.4 集成策略](#64-集成策略)
  - [6.5 验证与确认](#65-验证与确认)
- [7 项目支持活动](#7-项目支持活动)
  - [7.1 配置管理](#71-配置管理)
  - [7.2 度量和分析](#72-度量和分析)
    - [7.2.1 GQM](#721-gqm)
  - [7.3 决策分析](#73-决策分析)
- [8 定量管理](#8-定量管理)
  - [8.1 高成熟度项目管理](#81-高成熟度项目管理)
    - [8.1.1 CMMI与项目管理](#811-cmmi与项目管理)
    - [8.1.2 实现高成熟度](#812-实现高成熟度)
  - [8.2 软件项目定量管理](#82-软件项目定量管理)
    - [8.2.1 定量管理](#821-定量管理)
    - [8.2.2 定量管理的实施](#822-定量管理的实施)
  - [8.3 常用定量管理技术](#83-常用定量管理技术)
    - [8.3.1 非统计技术](#831-非统计技术)
      - [8.3.1.1 直方图](#8311-直方图)
      - [8.3.1.2 帕累托图](#8312-帕累托图)
      - [8.3.1.3 因果图](#8313-因果图)
      - [8.3.1.4 散布（点）图](#8314-散布点图)
    - [8.3.2 统计技术](#832-统计技术)
      - [8.3.2.1 控制图](#8321-控制图)
      - [8.3.2.2 回归分析](#8322-回归分析)
# 1 概述

## 1.1 软件危机

四大本质困难和挑战：复杂性、不可见性、可变性、一致性

### 1.1.1 软件危机 VS. 软件工程

1. 软件危机
   1. 软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。
2. 软件工程
   1. 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。
   2. 软件工程的两大视角
      1. 管理视角——能否复制成功？
      2. 技术视角——是否可以将问题解决得更好？

## 1.2 软件项目管理

### 1.2.1 概念

1. 管理的三大关键要素:目标、状态、纠偏
2. 软件项目管理
   1. 典型的三大目标：成本、质量、工期
   2. 软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。 
   3. 估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等 

### 1.2.2 管理视角

1. 软件过程
   1. 软件过程是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合
   2. 这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或者多个目标。 
2. 生命周期模型
   1. 对软件过程的一种人为的划分

#### 1.2.2.1 广义软件过程

1. 理论基石：软件产品和服务的质量，很大程度上取决于生产和维护该软件或者服务的过程的质量。
2. 广义软件过程包括**技术**、**人员**以及**狭义过程**
3. 广义软件过程的同义词：软件开发方法、软件开发过程
   1. 净室Cleanroom方法、极限编程方法、SCRUM方法、Gate方法；
   2. 而更一般的，敏捷软件过程／方法、轻量型过程／方法以及重型过程／方法等描述也是恰当的

#### 1.2.2.2 生命周期模型与软件过程

1. 区别和联系
   1. 生命周期模型是对一个软件开发过程的人为划分
   2. 生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分
   3. 生命周期模型往往不包括技术实践
2. 典型生命周期模型
   1. 瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等

## 1.3 软件过程管理

1. 管理对象是软件过程
2. 管理的目的是为了让软件过程在开发效率、质量等方面有着更好性能绩效（performance）
3. **管理视角的核心问题——能否复制成功？**

![image-20211227173952564](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227174803738.png)

4. （网络）软件过程管理的主要内容包括过程定义和过程改进
5. 软件过程管理模型：CMM/CMMI, SPICE
6. 软件过程改进模型：PDCA，IDEAL
7. ==**CMM/CMMI 不是软件开发方法，不是项目管理方法**==
8. IDEAL模型是软件过程改进的元模型，是基于软件开发的特征对传统行业PDCA模型的扩展，CMM以及后续的CMMI可以看作IDEAL模型的实例

![image-20211227174803738](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227173952564.png)

![image-20211227174807961](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227174807961.png)

![image-20211228223906116](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227192528141.png)![image-20211228223918591](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227191926863.png)

# 2 软件过程的历史演变和经典工作

软件开发的本质难题是：不可见性、复杂性、可变性、一致性；三个本质难题因项目而异，四大本质难题相互促进，本质难题变化带动软件方法（过程）演变

## 2.1 软件发展三大阶段

### 2.1.1 软硬件一体化阶段

1. 软硬件一体化阶段（50年代~70年代）

#### 2.1.1.1 软件完全依附于硬件

1. 软件完全依附于硬件

   1. 软件应用典型特征

      1. 软件支持硬件完成计算任务
      2. 功能单一
      3. 复杂度有限
      4. 几乎不需要需求变更

   2. 软件开发典型特征 “measure twice，cut once”

      1. 硬件太贵
      2. 团队以硬件工程师和数学家为主

      ![image-20211227191926863](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227192451935.png)

#### 2.1.1.2 软件作坊

1. 软件作坊
   1. 软件应用典型特征
      1. 功能简单
      2. 规模小
   2. 软件开发典型特征 “code and fix”——**不适合大型软件开发项目**
      1. 很多非专业领域的人员涌入软件开发领域
      2. 高级程序语言出现
      3. 质疑权威文化盛行

### 2.1.2 软件成为独立产品

1. 软件成为独立的产品（70年代~90年代）

   1. 软件应用特征

      1. 摆脱了硬件束缚（OS）
      2. 功能强大
      3. 规模和复杂度剧增
      4. 个人电脑出现—》普通人成为软件用户（需求多变，兼容性要求）
      5. 来自市场的压力

   2. 软件开发方法

      1. 形式化方法![image-20211227192528141](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228223906116.png)
      2. 结构化程序设计和瀑布模型![image-20211227192451935](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227220145499.png)

   3. 问题和不足（效率和质量）

      1. 形式化在扩展性和可用性方面存在不足
      2. 瀑布模型成为一个重文档，慢节奏的过程

   4. （网络）成熟度模型是一种工具，可以帮助人们评**估一个人或一个团队当前的有效性**，并分析他们下一步需要获得哪些能力以改善其绩效。 在许多领域，成熟度模型的名声很差，很容易被滥用，但在适当的情况下可能会有所帮助。 成熟度模型在软件行业里流行甚广，CMM（Capability Maturity Model）可以说是软件领域最著名的成熟度模型。

      ![image-20211227192830863](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227201945789.png)

   5. CMMI是过程改进模型而非软件过程或者软件过程模型；CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较

### 2.1.3 网络化和服务化

1. 网络化和服务化（90年代中期迄今）

   1. 软件应用特征

      1. 功能更复杂，规模更大
      2. 用户数量急剧增加
      3. 快速演化和需求不确定
      4. 分发方式的变化（SaaS）

   2. 软件开发方法

      1. 迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。

         1. 雪鸟会议和敏捷宣言

            1. 个体和互动胜过流程和工具
            2. 可以工作的软件胜过详尽的文档
            3. 客户合作胜过合同谈判
            4. 响应变化胜过遵循计划

            ![image-20211227201945789](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227211724338.png)

      2. XP（eXtreme Programing） 方法：偏重于一些工程实践的描述

      3. SCRUM：管理框架和管理实践

      4. Kanban：精益生产（丰田制造法）的具体实现；可视化工作流、限定WIP、管理周期时间

      5. 开源软件开发方法：是一种基于并行开发模式的软件开发的组织与管理方式 

         1. “Linus定律”：“如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。
         2. “早发布，常发布，倾听用户的反馈 ”、“把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径”、“设计上的完美不是没有东西可以再加，而是没有东西可以再减”
         3. 代码管理：严格的代码提交社区审核制度
         4. 一些演化：内部开源（inner source），众包(Crowdsourcing)

## 2.2 当前软件发展现状

1. 软件应用典型特征

   1. 进一步服务化和网络化（移动是主流）
   2. 用户需求多样性进一步凸显
   3. 软件产品和服务的地位变化
   4. 错综复杂的部署环境
   5. 近乎苛刻的用户期望
      1. 多：功能丰富，个性化
      2. 快：快速使用，及时更新，快速解决问题
      3. 好：稳定，可靠，安全，可信
      4. 省：用户的获得成本低，最好免费

2. 软件开发典型特征

   1. 空前强大的开发和部署环境——XaaS（即包含所有aas）

      [IAAS，PAAS，SAAS与XAAS的关系_Grimm的博客-CSDN博客](https://blog.csdn.net/grimmp/article/details/115430772)

      1. FaaS（Function asa Service，也即函数即服务）。FaaS 是Compute as a Service（计算即服务）的一种形式。
      2. Saas（software）
      3. paas（platform）
      4. iaas（infrastructure）

   2. 盛行共享和开源

   3. 潜在支撑获得了长足进步（AI，大数据，云）

## 2.3 典型DevOps实践和方法

1. 方法论基础是敏捷软件开发、精益思想以及看板Kanban方法。
2. 以领域驱动设计为指导的微服务架构方式
3. 大量虚拟化技术的使用
4. 一切皆服务XaaS(X as a Service)的理念指导
5. 构建了强大的工具链，支持高水平自动化



# 3 团队动力学

## 3.1 理论前提

### 3.1.1 软件开发是知识工作

1. 软件开发是一项既复杂又富有创造性的知识工作
2. 软件开发——智力劳动
   1. 处理和讨论极其抽象的概念
   2. 把不同的部分（不可见）整合成一个可以工作的系统
3. 这就要求从事软件开发的工程师必须全身心地参与工作，n主观意愿上努力追求卓越
4. 这就要求管理者激励并且维持激励

### 3.1.2 知识工作管理

1. 管理知识工作的关键规则是：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。
2. 要自我管理，知识工作者必须有积极性，能做出准确的估算和计划，懂得协商承诺，有效跟踪他们的计划，持续地按计划交付高质量产物
3. 知识工作者实现自我管理：胶冻状团队
4. 知识工作者的管理需要的是领导者，而不是经理。

### 3.1.3 领导者激励手段

1. 有3种主要的激励方式：威逼、利诱、鼓励承诺
2. 马斯洛的需求层次理论![image-20211227211724338](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227192830863.png)
   1. 自我实现是最高的层次
   2. 激励来自为没有满足的需求而努力奋斗
   3. 低层次的需求必须在高层次需求满足之前得到满足
   4. 满足高层次的需求的途径比满足低层次的途径更为广泛
3. 三种激励方式对应的领导方式
   1. 交易型领导方式——威逼利诱
      1. 承诺奖励激励
      2. 人们通常能找到新的方式来获得奖励，同时少做工作
   2. 转变型领导方式——鼓励承诺
      1. 用成就激励
   3. 由于交易型领导方式很少能产生成功的并且有创造性的团队，因此转变型领导方式是首选
4. 承诺形式的激励
   1. 在个人级别，有很大的差异：有的人认真，有的人不认真
   2. 当满足以下情况，团队承诺比个人承诺的激励作用更大：
      1. 所有团队成员共同参与作出承诺。
      2. 团队依赖于每一位成员履行自己的承诺。
   3. 一个软件开发团队在制定承诺时，要保证：承诺是自愿的，公开的，可信的/可行的，向团队承诺

### 3.1.4 维持激励水平

1. 需要及时的绩效反馈，包括
   1. 根据一个详细计划衡量进度
   2. 当前计划不准确时重做计划
   3. 为漫长而富有挑战性的项目提供中间反馈，即里程碑
2. 其他激励相关理论
   1. 海兹伯格的激励理论
      1. 激励因素（内在因素）：成就感，责任感，晋升，被赏识、认可
      2. 保健因素（外在因素）：工作环境，薪金，工作关系，安全等
   2. 麦克勒格的 X－理论 和 Y －理论 
      1. X——理论
         1. 不喜欢他们的工作并努力逃避工作
         2. 缺乏进取心，没有解决问题与创造的能力
         3. 更喜欢经常的指导，避免承担责任，缺乏主动性
         4. 自我中心，对组织需求反应淡漠，反对变革
         5. 用马斯洛的底层需求（生理和安全）进行激励
      2. Y——理论
         1. 如果给予适当的激励和支持性的工作氛围，会达到很高的绩效预期
         2. 具有创造力，想象力，雄心和信心来实现组织目标
         3. 能够自我约束，自我导向与控制，渴望承担责任
         4. 用马斯洛的高层需求（自尊和自我实现）进行激励
   3. 期望理论
      1. 人们在下列情况下能够受到激励并且出大量成果 M = V * E
         1. 相信他们的努力很可能会产生成功的结果(V)
         2. 他们也相信自己会因为成功得到相应的回报(E)
      2. 提升成功把握的两种方式：“现实扭曲立场”，数据的收集

## 3.2 自主团队

### 3.2.1 自主团队的特点

1. 自主团队具备如下的特点：
   1. 自行定义项目的目标
   2. 自行决定团队组成形式以及成员的角色
   3. 自行决定项目的开发策略
   4. 自行定义项目的开发过程
   5. 自行制定项目的开发计划
   6. 自行度量、管理和控制项目工作

### 3.2.2 自主团队的外部环境

1. 项目启动阶段获得管理层的支持
   1. 项目小组应当体现出已经尽最大的可能在满足管理层的需求的工作态度。
   2. 项目小组应当在计划中体现定期需要向管理层报告的内容。
   3. 项目小组应当向管理层证明他们所制定的工作计划是合理的。
   4. 项目小组应当在计划中体现为了追求高质量而开展的工作。
   5. 项目小组应当在工作计划中允许必要的项目变更。
   6. 项目小组应当向管理层寻求必要的帮助。
2. 在项目进展过程中获得管理层的支持
   1. 项目小组应当严格遵循定义好的开发过程开展项目开发工作。
   2. 项目小组应当维护和更新项目成员的个人计划和团队计划。
   3. 项目小组应当对产品质量进行管理。
   4. 项目小组应当跟踪项目进展，并定期向管理层报告。
   5. 项目小组应当持续地向管理层展现优异的项目表现。

## 3.3 TSP对自主团队的实现

![](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227220242070.png)![image-20211227220242070](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211227220532219.png)

### 3.3.1 典型TSP角色

领导者与经理的区别

![image-20211227220532219](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228141005305.png)

#### 3.3.1.1　项目组长 TL

1. 项目组长的目标和衡量指标
   1. 项目组长应当建设和维持高效率的团队。
   2. 项目组长应当激励团队成员积极工作。
   3. 项目组长应当合理处理团队成员的问题。
   4. 项目组长应当向管理层提供项目进度相关的完整信息。
   5. 项目组长应当充当合格的会议组织者和协调者。
2. 典型TL技能
   1. 你是天生的领导者
   2. 你有能力识别问题的关键并且做出客观的决策
   3. 你不介意偶尔充当“恶人”
   4. 你尊敬你的团队成员
3. TL工作内容
   1. 团队成员努力工作
   2. 主持项目周例会
   3. 每周汇报项目状态
   4. 分配工作任务
   5. 维护项目资料
   6. 组织项目总结

#### 3.3.1.2　计划经理

1. 计划经理的目标和衡量指标
   1. 开发完整的、准确的团队计划和个人计划
   2. 每周准确的报告项目小组状态
2. 典型技能
   1. 最为重要的一点是，你做事有条理和逻辑
   2. 你对于过程数据非常感兴趣，期待通过每周输入的数据来了解项目当前状况
   3. 你认为计划非常重要，也愿意要求团队成员跟踪和度量他们的工作
3. 主要工作内容
   1. 带领项目小组开发项目计划
   2. 带领项目小组平衡计划
   3. 跟踪项目进度
   4. 参与项目总结

#### 3.3.1.3　开发经理

1. 目标和衡量指标	

   1. 开发优秀的软件产品
   2. 充分利用团队成员的技能

2. 有助于开发经理的技能

   1. 你喜欢创造事物

   2. 你愿意成为软件工程师，并且喜欢带领团队开展设计和开发工作

   3. 你具备足够的背景可以胜任设计师的工作，并且可以领导设计团队开展工作

      你熟悉主流的设计工具

   4. 你愿意倾听和接受其他人的设计思想

3. 主要工作内容

   1. 带领团队制定开发策略。
   2. 带领团队开展产品规模估算和所需时间资源的估算。
   3. 带领团队开发需求规格说明。
   4. 带领团队开发高层设计。
   5. 带领团队开发设计规格说明。
   6. 带领团队实现软件产品。
   7. 带领团队开展集成测试和系统测试。
   8. 带领团队开发用户支持文档。
   9. 参与项目总结

#### 3.3.1.4 质量经理

1. 目标和衡量指标
   1. 项目团队严格按照质量计划开展工作，开发出高质量的软件产品
   2. 所有的小组评审工作都正常开展，并且都形成了评审报告
2. 有助于质量经理的技能
   1. 你关注软件产品的质量
   2. 你有评审方面的经验，熟悉各种评审方法
   3. 你有协调组织有效评审的能力
3. 主要工作内容
   1. 带领团队开发和跟踪质量计划
   2. 向项目组长警示质量问题
   3. 软件产品提交配置管理之前，对其进行评审，以消除质量问题
   4. 项目小组评审的组织者和协调者
   5. 参与项目总结

#### 3.3.1.5 过程经理

1. 目标和衡量指标
   1. 所有团队成员准确的记录、报告和跟踪过程数据。
   2. 所有的团队会议都有相应会议记录。
2. 技能
   1. 你对过程定义、过程度量非常感兴趣
   2. 你对过程改进非常感兴趣
3. 主要工作内容
   1. 带领团队定义和记录开发过程并且支持过程改进。
   2. 建立和维护团队的开发标准。
   3. 记录和维护项目的会议记录。
   4. 参与项目总结。

#### 3.3.1.6 支持经理

1. 目标和衡量指标
   1. 项目小组在整个开发过程中都有合适的工具和环境
   2. 对于基线产品，不存在非授权的变更
   3. 项目小组的风险和问题得到跟踪
   4. 项目小组在开发过程中满足复用目标
2. 技能
   1. 你对于各种开发工具很感兴趣，熟悉各类工具的适用场合。
   2. 你对版本控制工具很熟悉，也熟悉配置管理流程。
   3. 对于本项目所有工具而言，你都是专家。
3. 主要工作内容
   1. 带领团队识别开发过程中所需要的各类工具和设施。
   2. 主持配置管理委员会，管理配置管理系统。
   3. 维护软件项目的词汇表。
   4. 维护项目风险和问题跟踪系统。
   5. 支持软件开发过程中复用策略的应用。
   6. 参与项目总结。

#### 3.3.1.7 开发人员

## 3.4 SCRUM中的角色

1. 典型SCRUM小组角色
   1. 一名产品负责人
   2. 一名 SCRUM Master
   3. 开发团队
2. SCRUM团队是跨职能的自组织团队

### 3.4.1 产品负责人

1. 职责：将开发团队开发的产品价值最大化
2. 工作：负责管理产品待办列表的唯一负责人。产品待办列表的管理包括
   1. 清晰地表述产品待办列表项；
   2. 对产品待办列表项进行排序，使其最好地实现目标和使命；
   3. 优化开发团队所执行工作的价值；
   4. 确保产品待办列表对所有人是可见、透明和清晰的，同时显示 Scrum 团队下一步要做的工作
   5. 确保开发团队对产品待办列表项有足够深的了解

### 3.4.2 开发团队

1. 职责：在每个Sprint结束时交付潜在可发布并且“完成”的产品增量
2. 开发团队由组织组建并得到授权，团队自己组织和管理他们的工作。开发团队具有下列特点：
   1. 他们是自组织的。没有人（即使是 Scrum Master）有权告诉开发团队应该如何把产品待办列表变成潜在可发布的功能增量；
   2. 开发团队是跨职能的团队，团队作为一个整体，拥有创建产品增量所需的全部技能；
   3. Scrum 不认可开发团队成员的任何头衔，不管其承担何种工作（他们都叫开发人员）。
   4. Scrum 不认可开发团队中所谓的“子团队”，无论其需要处理的领域是诸如测试、架构、运维或业务分析
   5. 开发团队中的每个成员也许有特长和专注的领域，但是责任属于整个开发团队。 

### 3.4.3 Scrum Master

1. 促进和支持SCRUM
2. 帮助每个人理解SCRUM理论、实践、规则和价值
3. SCRUM Master 是一位服务型领导。
   1. 帮助 SCRUM 团队之外的人了解如何与 SCRUM 团队交互是有益的
   2. 改变SCRUM 团队之外的人与 SCRUM 团队的互动方式来最大化 SCRUM 团队所创造的价值。
4. Scrum Master 服务于产品负责人，包括：
   1. 确保 Scrum 团队中的每个人都尽可能地理解目标、范围和产品域；
   2. 找到有效管理产品待办列表的技巧；
   3. 帮助 Scrum 团队理解为何需要清晰且简明的产品待办列表项；
   4. 理解在经验主义的环境中的产品规划；
   5. 确保产品负责人懂得如何来安排产品待办列表使其达到最大化价值；
   6. 理解并实践敏捷性；
   7. 当被请求或需要时，引导 Scrum 事件。
5. Scrum Master 以各种方式服务于开发团队，包括
   1. 作为教练在自组织和跨职能方面给予开发团队以指导；
   2. 帮助开发团队创造高价值的产品；
   3. 移除开发团队工作进展中的障碍；
   4. 按被请求或需要时，引导 Scrum 事件；
   5. 在 Scrum 还未完全采纳和理解的组织环境中，作为教练指导开发团队。
6. Scrum Master 以各种方式服务于组织，包括：
   1. 带领并作为教练指导组织采纳 Scrum；
   2. 在组织范围内规划 Scrum 的实施；
   3. 帮助员工和利益攸关者理解并实施 Scrum 和经验导向的产品开发；
   4. 引发能够提升 Scrum 团队生产率的改变；
   5. 与其他 Scrum Master 一起工作，增强组织中 Scrum 应用的有效性。

# 4 估算、计划和跟踪

## 4.1 估算

### 4.1.1 估算概述

1. 估算目的是给各类计划提供决策依据
2. 估算对象（规模、时间和日程）
3. 估算是主观猜测
4. 估算能力很难提升
5. 没有任何人知道准确的数字究竟是什么
6. 多项实证研究表明，是否使用估算模型并没有显著差异

### 4.1.2 PSP和PROBE

1. 规模度量/估算的困境
   1. 精确度量方式往往不便于早期规划/估算
   2. 有助于早期规划/估算的度量往往难以产生精确度量结果

#### 4.1.2.1 PROBE

1. PROBE（PROxy Based Estimation）的作用
   1. 精确度量和早期规划之间的桥梁
2. 估算流程![image-20211228141005305](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228144846139.png)
3. 概要设计
   1. 估算的第一步
      1. 与已有产品/组件相关联
      2. 定义能够产生期望功能的产品元素
      3. 估算你计划构造之物的规模
   2. 对于大多数的项目，概要设计都应相对较快地完成
   3. 为了做出概要设计，需要确定产品功能，以及产生这些功能所需的程序组件/模块；然后，将这些程序组件/模块与你以前写的程序相比较，估算他们的规模；最后，将程序组件/模块估算综合给出总规模
   4. “如果你对产品的理解还不足以产出一个概要设计，那么你所知道的还不足以做出一个计划”
4. 整合多个估算结果
   1. 整合一个开发人员做的多个估算
      1. 累积各个部分的估算
      2. 进行一次线性回归计算
      3. 计算一个预测区间
   2. 多个开发人员可以整合独立进行的估算，通过以下方式
      1. 进行单独的线性回归预测
      2. 将计划的规模或者时间相加
      3. 将个人范围的平方相加，再对其计算平方根获得预测区间
   3. 当估算多个部件时，总的误差会比各个部件误差的总和要小：误差趋于抵消；假设没有共同的偏差
   4. **估算要点之一**：尽可能详细划分
5. PROBE方法依赖历史数据，但是实际历史数据有可能
   1. 历史数据少于3个数据点；
   2. 有足够的历史数据，但是数据的质量不高
6. 估算规模![image-20211228144846139](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228223918591.png)
7. 估算时间![image-20211228144858821](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228143536657.png)

#### 4.1.2.2 历史数据的获取——度量

1. 关于度量的争议：度量体现着决策者对试图要实现的目标的关切程度

#### 4.1.2.3 PSP时间度量（时间日志）

![image-20211228143445361](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228143445361.png)

![image-20211228143536657](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228144858821.png)

#### 4.1.2.4 PSP缺陷度量（缺陷日志）

![image-20211228143608121](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228143121314.png)

### 4.1.3 SCRUM和故事点

1. 度量实现一个故事（Story）需要付出的工作量
   1. 抽象的：混合了对于开发特性（feature）所要付出的努力、开发复杂度、个中风险以及类似东西
   2. 相对的：设定标准之后，考虑其他特性（feature）与标准之间的相对大小关系
2. **估算要点之二**：建立对结果的信心
3. **估算要点之三**：依赖数据
4. **估算要点之四**：估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程

### 4.1.4 怎么做估算

1. 要点
   1. 达成共识
   2. 建立信心：足够详细，依赖数据，最好的猜测（注意检验猜测所依据的假设）
2. 线性回归方法![image-20211228143121314](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228143608121.png)
3. 预测区间计算方法![image-20211228143140292](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228143140292.png)

### 4.1.5 历史数据的处理

#### 4.1.5.1 简单方法

1. 基本思想
   1. 将每个方法的代码行数进行排序
   2. 选择最小值作为VS；
   3. 选择最大值作为VL；
   4. 选择中值作为M；
   5. 选择VS与M的均值作为S；
   6. 选择VL与M的均值作为L。

#### 4.1.5.2 正态分布法

1. 使用正态分布法的计算方法如下：
   1. 选择所有数据的均值作为M，计算所有数据的
      标准差σ。
   2. 那么S = M- σ ，VS = M-2 σ ，L = M+ σ ，VL
      = M+2 σ 。

#### 4.1.5.3 对数正态分布

1. 原因：
   1. 大部分人习惯写很多规模很小的程序，少量规
      模较大的程序
   2. 程序的规模不可能出现负数
2. 计算方法：
   1. 以e为底计算所有数据的自然对数；
   2. 计算取对数之后的值的均值作为M，计算相应标
      准差σ。
   3. 那么S = M- σ ，VS = M-2 σ ，L = M+ σ ，VL =
      M+2 σ 。
   4. 取反对数；

#### 4.1.5.4 三种方法对比

1. 简单方法
   1. 计算简单
   2. 不稳定
2. 正态分布法
   1. 相对稳定，在历史数据基本符合正态分布的情况下，可以给出非常好的相对大小矩阵
3. 对数正态分布法
   1. 更加符合人们对于程序的规模的直观感觉

#### 4.1.5.5 相关性

1. 相关性描述的是两组变化的数据之间相互关联的程度;
2. 一般情况下，为确保估算质量，对于历史数据的相关性要求r≥0.7。

![image-20211228144613454](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228144613454.png)

#### 4.1.5.6 显著性

1. 它描述的是上述两组数据的相关关系出现的偶然性
2. 因此，显著性越小越好。软件工程很多场合下要求显著性s≤0.05（即所谓p值）

#### 4.1.5.7 极端数据

1. PROBE A方法和B方法的时候，对于数据的相关性有要求。
2. 然而很多时候，历史数据中的一些极端数据会造成相关性的“假象”。
3. 

## 4.2 计划和跟踪

### 4.2.1 团队项目规划

工作分解结构、开发策略与计划、生命周期模型、日程/质量/风险计划等

#### 4.2.1.1 工作分解结构 WBS：Work Breakdown Structure

1. 定义：跟因数分解是一个原理，就是把一个项目，按一定的原则分解，项目分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的日常活动中，直到分解不下去为止。

2. WBS作用

   1. 范围基线
   2. 提供整体观
   3. 不遗漏可交付物
   4. 明确各个角色的责任
   5. 工作包定义
   6. 估算和计划的基础
   7. 理解工作，分析风险

3. 示例

   ![image-20211228145457994](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228145457994.png)

4. 创建WBS方法

   1. 识别和分析可交付成果及相关工作；
   2. 确定工作分解结构的结构与编排方法；
   3. 自上而下逐层细化分解；
   4. 为工作分解结构组成部分制定和分配标志编码；
   5. 核实工作分解的程度是必要且充分的

5. 好的WBS检查标准

   1. 最底层要素不能重复，即任何一个工作包应该在WBS中的一个地方且只应该在WBS中的一个地方出现。
   2. 所有要素必须清晰完整定义，即相应的数据词典必须完整定义。
   3. 最底层要素必须有定义清晰的责任人，可以支持成本估算和进度安排。
   4. 最底层的要素是实现目标的成分必要条件，即项目的工作范围得到完整体现。

#### 4.2.1.2 范围管理

1. 包括确保项目做且只做成功完成项目所需的全部工作的各过程。
2. WBS为范围管理提供了基准。
3. 过程
   1. 收集需求
   2. 定义范围
   3. 创建WBS
   4. 核实范围
   5. 控制范围变更

#### 4.2.1.3 开发策略与计划

1. 开发策略是在产品组件需求基础之上，明确每个产品组件的获得方式与顺序，从而在项目团队内部建立起大家都理解的产品开发策略。
2. 注意事项：WBS的使用，产品组件开发顺序的考虑，产品组件获得方式的考虑

#### 4.2.1.4 过程框架——生命周期模型

![image-20211228183144164](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228183144164.png)

#### 4.2.1.5 通用计划框架

![image-20211228183210161](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228183305310.png)

#### 4.2.1.6 日程计划原理和方法

1. 任务计划和日程计划

   ![image-20211228183305310](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228183329899.png)![image-20211228183311362](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228183210161.png)![image-20211228183329899](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228183311362.png)

2. 典型计划流程回顾

   1. 估算规模
   2. 估算资源
   3. 规划日程

#### 4.2.1.7 质量计划原理和方法

1. 项目的质量计划中应当确定需要开展的质量保证活动
2. 典型的质量保证活动包括个人评审、团队评审、单元测试、集成测试、系统测试以
   及验收测试等。
3. 在质量计划中需要解决的关键的问题是该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标分别是什么。

#### 4.2.1.8 风险计划

1. 风险管理的目的是在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。
2. 风险管理大致分成两部分，即风险识别和风险应对。
3. 风险识别
   1. 识别与成本、进度及绩效相关的风险
   2. 审查可能影响项目的环境因素
   3. 审查工作分解结构的所有组件，作为风险识别的一部分，以协助确保所有的工作投入均已考虑
   4. 审查项目计划的所有组件，作为风险识别的一部分，以确保项目在各方面均已考虑
   5. 记录风险的内容、条件及可能的结果
   6. 识别每一风险相关的干系人
   7. 利用已定义的风险参数，评估已识别的风险
   8. 依照定义的风险类别，将风险分类并分组
   9. 排列降低风险的优先级
4. 风险应对
   1. 识别风险之后，就应当制定相应的风险管理策略，以应对各类风险
   2. 典型的策略包括
      1. 风险转嫁
      2. 风险解决
      3. 风险缓解

#### 4.2.1.9 计划评审和各方承诺

1. 项目各项计划完成之后，需要与各类计划的相关干系人开展评审工作，解决计划中相互矛盾与不一致的地方，并获得参与项目的各方对项目计划的承诺。
   1. 识别每一项计划所需支持，并与相关干系人协商承诺
   2. 记录所有的承诺，包括完整的承诺和临时的承诺，并确保由适当层次的人员签署。
   3. 适时与资深管理人员一起审查承诺。

### 4.2.2 团队项目跟踪与管理

挣值管理、里程碑评审、纠偏活动管理

#### 4.2.2.1 项目跟踪意义

1. 在项目进展过程中开展跟踪活动的目的在于了解项目进度，以便在项目实际进展与计划产生严重偏离时，可采取适当的纠正措施。
2. 项目进度滞后与否需要参照物，即项目计划
3. 项目跟踪需要管理针对偏差而采取的纠偏措施。

##### 4.2.2.1.1 挣值管理方法

1. 项目的挣值管理方法(Earned Value Management，简称EVM)是用来客观度量项目进度的一种项目管理方法。
   1. 每项任务实现附以一定价值（credit）
   2. 100%完成该项任务，就获得相应价值
2. EVM采用与进度计划、成本预算和实际成本相
   联系的三个独立的变量，进行项目绩效测量。

![image-20211228184132743](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228191139161.png)

1. BAC表示按照PV值的曲线，当项目完成的
   时候所需预算或者时间
2. 成本差异CV = EV-AC
3. 成本差异指数CPI = EV/AC
4. 日程偏差SV = EV – PV
5. 日程偏差指数SPI = EV/PV
6. 预计完成成本EAC = AC+(BAC-EV)/CPI =BAC/CPI

![image-20211228184429003](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228184429003.png)

1. EVM的局限性
   1. EVM一般不能应用软件项目的质量管理。
   2. EVM需要定量化的管理机制，这就使其在一些探索型项目以及常用的敏捷开发方法中的应用受到限制
   3. EVM完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算

##### 4.2.2.1.2 里程碑评审

1. 软件项目的里程碑往往是指某个时间点，用以标记某项工作的完成或者阶段的结束
2. 审查的内容包括：
   1. 项目相关的承诺，如日期、规格、质量等等
   2. 项目各项计划的执行状况；
   3. 项目当前的状态讨论
   4. 项目面临的风险讨论等。

##### 4.2.2.1.3 其他计划跟踪

1. 日程计划跟踪
2. 承诺计划跟踪
3. 风险计划跟踪
4. 数据收集计划跟踪
5. 沟通计划跟踪

#### 4.2.2.2 纠偏活动的管理

1. 偏差原因分析
2. 纠偏措施定义
3. 纠偏措施管理

## 4.3 项目总结

### 4.3.1 项目总结的意义

1. 软件项目的特点决定了持续改善对于软件工程师的重要性
2. Rita Mae Brown在书中写到的那样“所谓的愚蠢（Insanity）就是反复做同样的事情，但是期望有不同的结果”
3. 提供一个系统化的方式来总结经验教训、防止犯同样的错误、评估项目团队绩效、积累过程数据等。提供给项目团队成员持续学习和改进的机会。

### 4.3.2 项目总结过程

1. 项目总结需要系统化有条理的进行，才能不遗漏重要的内容。因此往往需要事先定义总结过程，然后按部就班开展总结工作
2. 包括
   1. 准备阶段
   2. 总结阶段
   3. 报告阶段

#### 4.3.2.1 基于PMBOK的总结

范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理和整合管理9大知识领域

##### 4.3.2.1.1 范围管理

1. 项目范围包括产品范围和项目范围。对项目范围管理的总结应当主要关注项目的需求开发过程与变更管理中的得失，对需求管理实际执行情况的差距进行原因分析，找到改进的机会。
   1. 是否有未被识别的需求？
   2. 是否有没有得到响应的需求变更？
   3. 需求是否出现蔓延现象等。

##### 4.3.2.1.2 时间管理

1. 项目时间管理所关注的就是项目的日程计划以及对日程计划的跟踪和管理状况
   1. 估算偏差有多大？
   2. 日程计划准确程度如何？
   3. 里程碑偏差有多大？
   4. 日程计划有什么变更？为什么？

##### 4.3.2.1.3 成本管理

1. 成本管理包括对成本进行估算、预算和控制的各个过程，从而确保项目在批准的预算内完工
   1. 项目计划投入总时间是多少？实际是多少？
   2. 各个阶段计划投入时间是多少？实际是多少？
   3. 偏差的原因是什么？

##### 4.3.2.1.4 质量管理

1. 项目质量管理包括执行组织确定质量政策、目标与职责的各过程和活动，从而使项目满足其预定的需求。
   1. 项目整体质量状况如何？
   2. 验收测试缺陷率是多少？
   3. 有没有办法在前期消除这些缺陷？

##### 4.3.2.1.5 项目人力资源管理

1. 项目人力资源管理包括组织、管理与领导项目团队的各个过程。
   1. 项目的生产效率如何？
   2. 每个人的生成效率如何？
   3. 每个人对项目的满意程度如何？
   4. 有没有提升的办法？

##### 4.3.2.1.6 项目沟通

1. 项目沟通管理包括为确保项目信息及时且恰当地生成、收集、发布、存储、调用并最终处置所需的各个过程
   1. 项目有没有因为沟通不够导致问题？
   2. 各个项目干系人沟通手段有哪些？有没有需要总结的经验教训？
   3. 什么样的沟通方法最为有效？

##### 4.3.2.1.7 项目风险管理

1. 项目风险管理包括风险管理规划、风险识别、风险分析、风险应对规划和风险监控等各个过程。
   1. 哪些问题在前期没有预料的相应的风险？为什么？
   2. 哪些风险应对措施比较有效？
   3. 就组织层面考察，哪些风险发生的频度较高？
   4. 整个风险管理有哪些经验教训？

##### 4.3.2.1.8 采购管理

1. 项目采购管理包括从项目组织外部采购或获得所需产品、服务或成果的各个过程
   1. 项目方案是否合理？
   2. 各类采购而得的工具是否合用？
   3. 供应商服务的评价？
   4. 采购相应的成本和风险考虑？
   5. 项目合同管理的经验教训有哪些？

##### 4.3.2.1.9 整合管理

1. 项目整合管理包括为识别、定义、组合、统一与协调项目管理过程组的各过程及项目管理活动而进行的各种过程和活动
   1. 各类计划之间是否协调一致？
   2. 团队章程的执行状况怎样？
   3. 项目变更的处理流程是否有效？
   4. 项目完成之后相应的产物是否得到妥善保存？
   5. 有没有对组织过程资产的更新？

#### 4.3.2.2 TSP项目总结介绍

1. TSP也提供了一种项目总结的方式，在这种方式当中，团队成员结合自己的角色，总结自己角色相关工作的得失，提出下一个开发周期的改进建议。
2. 典型角色包括项目组长、计划经理、开发经理、质量经理、过程经理和支持经理等
3. 总结过程阶段
   1. 准备阶段
   2. 过程数据评审阶段
   3. 人员角色评价阶段
   4. 总结报告撰写阶段

##### 4.3.2.2.1 过程数据评审阶段

1. 该阶段往往由过程经理或者质量经理带领整个团队分析过程数据，识别过程改进机会。
2. 可以结合典型TSP团队角色，逐个讨论改进领域。如团队领导力、计划准确性、过程优劣、质量管理能力、开发环境以及配置管理等。
3. 此外，也可以就TSP教练的作用进行评价
4. 过程数据评审阶段还要求开发团队的所有成员都整理过程改进提案（PIP）。

##### 4.3.2.2.2 人员角色评审

1. 项目组长
   1. 项目组长的角色评审应当从领导力角度开考察团队的表现。
   2. 重点关注团队激励和团队承诺方面的问题
   3. 项目会议的组织情况也需要总结。比如，会议效果、讨论技巧等。
   4. 此外，还应当就如何在下一周期做得更好
      提出改进建议。
2. 计划经理
   1. 计划经理主要关注项目进度，因此，在总结阶段需要就估算、生产效率、里程碑等话题进行总结。
      1. 项目产品规模的估算值和实际值有多大的偏差？为什么有这些偏差？
      2. 项目的计划开发时间以实际开发时间有没有偏差？原因是什么？
      3. 项目整体的生产效率是多少？
      4. 人均资源水平有多少？
      5. 项目的PV与EV趋势是什么？为什么有偏差？
      6. 跟以前的开发周期相比，生产效率有没有提升？为什么？
      7. 下一个开发周期需要如何提升？
3. 开发经理
   1. 开发经理进行总结的时候，应当从开发内容和开发策略角度出发，总结得失；质量话题也应当提出见解
      1. 将实际开发结果与计划开发内容进行对比，看看是否完全实现需求？
      2. 或者从开发策略角度考察，看看事先定义的开发策略是否有效？如何改进？
      3. 现有的设计和实现步骤是否有助于质量目标的实现？
      4. 对于可用性、性能以及兼容性等其他高层次质量要求，现有的设计方法和实现平台是否可以支持？
      5. 现有的质量度量方式效果如何？未来怎样改进？
4. 质量经理
   1. 质量经理的总结则应该从项目整体质量状况出发，总结质量目标的实现过程，并找出改进机会。
      1. 项目整体质量状况如何？质量目标实现了吗？为什么？
      2. 是否所有预定的质量管理活动都开展了？如果没有，为什么
      3. 项目进展过程中，质量趋势是什么？
      4. 每个阶段的yield分别是什么？为什么有的过低？
      5. 测试开始之后有多少缺陷？哪些缺陷可以通过什么样的方式在前期排除？
      6. 现有的质量管理手段的效果如何？有哪些需要改进？
5. 过程经理
   1. 过程经理关注团队遵循过程的程度和过程改进方案
      1. 是否所有人都如实记录数据？
      2. 团队成员对过程遵循状况如何？为什么？
      3. 记录的过程数据说明了什么？
      4. 现有的过程有哪些不足？
      5. 所有的PIP都提交了吗？
      6. 哪些PIP值得在下个周期实现？如果要实现，对现有过程需要做什么样的调整？
6. 支持经理
   1. 支持经理主要关注配置管理状况、问题和风险跟踪机制以及复用策略的支持等话题
      1. 项目团队开发环境是否合用？
      2. 项目过程中，对于配置项出现了几次变更？原因分别是什么？未来如何改进？
      3. 配置管理活动开展情况如何？是否有未经授权的配置项修改现象出现？
      4. 风险和问题跟踪机制是否有效？是否所有问题都得到处理？
      5. 风险有没有导致对项目的负面影响？
      6. 哪些风险一开始没有被识别出来？
      7. 复用策略是否有效？
      8. 对比上一阶段，复用比例是否上升？为什么？怎么改进？
7. 工程师
   1. 此外，由于大部分角色经理同时充当着软件工程师的角色，因此，还需要就工程师角色的工作状况进行总结。工程师重点关注的就是个人的绩效（生产效率、质量水平等）。
      1. 个人计划的绩效与实际的绩效有没有差别？为什么有偏差？
      2. 对比上个周期有没有进步？为什么？
      3. 下个开发周期将如何改进？
      4. 根据个人总结的PIP，你觉得最值得改进的有哪些内容？

### 4.3.3 项目总结报告模板

![image-20211228191139161](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228191624945.png)



# 5 质量管理

## 5.1 质量概念

1. 面向用户的质量观
   1. PSP 中也采用了面向用户的视图，定义质量为满足用户需求的程度。在这个定义中，就需要进一步明确：
      1. 用户究竟是谁？
      2. 用户需求的优先级是什么？
      3. 这种用户的优先级对软件产品的开发过程产生什么样的影响？
      4. 怎样来度量这种质量观下的质量水平？

## 5.2 PSP质量策略

1. 用缺陷管理来替代质量管理；
2. 高质量产品也就意味着要求组成软件产品
   的各个组件基本无缺陷；
3. 各个组件的高质量是通过高质量评审来实现的

### 5.2.1 不同缺陷消除方式消除缺陷的效率

![image-20211228191624945](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228200621608.png)

#### 5.2.1.1  测试消除缺陷的典型流程

1. 发现待测程序的一个异常行为；
2. 理解程序的工作方式；
3. 调试程序，找出出错的位置，确定出错原因；
4. 确定修改方案，修改缺陷；
5. 回归测试，以确认修改有效

#### 5.2.1.2 评审发现缺陷典型流程

1. 遵循评审者的逻辑来理解程序流程；
2. 发现缺陷的同时，也知道了缺陷的位置和 原因；
3. 修正缺陷；

![image-20211228200621608](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228202959730.png)

### 5.2.2 PSP评审过程质量

1. 评审检查表
2. 质量控制指标
3. 其他因素
   1. 环境
   2. 评审时机
   3.  个人评审和小组评审
   4. 缺陷预防

#### 5.2.2.1 质量指标之一 ：Yield

1. Yield指标用以度量每个阶段在消除缺陷方面 的效率。

   1. Phase Yield = 100 * (某阶段发现的缺陷个数)/( 某阶段注入的缺陷个数+进入该阶段前遗留的缺 陷个数)
   2. Process Yield = 100 * (第一次编译前发现的缺 陷个数)/(第一次编译前注入的缺陷个数)；

   ![image-20211228202959730](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228213323500.png)

#### 5.2.2.2 质量指标之二 ：A/FR

A/FR = PSP质检成本/PSP失效成本

![image-20211228213323500](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228213644680.png)

控制目标：

1. 理论上，A/FR的值越大，往往意味着越高 的质量。
2. 过高的A/FR往往意味着做了过多的评审， 反而会导致开发效率的下降。作为指南，
3. 在PSP中A/FR的期望值就是2.0

#### 5.2.2.3 质量指标之三：PQI

1. 5个数据乘积

   1. 设计质量：设计的时间应该大于编码的时间
   2. 设计评审质量：设计评审的时间应该大于设计时间的 50%
   3. 代码评审质量：代码评审时间应该大于编码时间的50%
   4. 代码质量：代码的编译缺陷密度应当小于10个/千行
   5. 程序质量：代码单元测试缺陷密度应当小于5个/千行

2. PQI与交付后缺陷密度的关系![image-20211228213644680](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228214011899.png)

3. PQI与集成时缺陷数的关系

   ![image-20211228213706413](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228214639645.png)

#### 5.2.2.4 质量指标之四：Review Rate

1. 评审的速度(Review Rate)是一个用以指导软 件工程师开展有效评审的指标
2. 高质量的评审需要软件工程师投入足够的时间 进行评审
3. 在PSP的实践中，代码评审速度小于200  LOC/小时，文档评审速度小于4 Page/小时

#### 5.2.2.4 质量指标之五：DRL

1. 缺陷消除效率比度量的是不同缺陷消除手段消除缺陷的效率。
2. 其计算方式是以某个测试阶段（一般为单元测试）每小时发现 的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每 小时发现的缺陷的比值就是DRL。

![image-20211228214011899](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228214729239.png)

#### 5.2.2.5 评审的其他考虑因素

1. 打印后评审往往效果更好
   1. 单个屏幕可以展现的内容比较有限
   2. 评审人员的注意力
2. 评审时机选择
   1. 编译（UT）之前 VS. 之后
3. 个人评审和小组评审
   1. 小组评审意义
   2. 先后顺序

### 5.2.3 PSP设计过程

#### 5.2.3.1 质量路径 Quality Journey

为了追求极高的质量，你有哪些手段？

1. Step 1：各种测试
2. Step 2：进入测试之前的产物质量提升
3. Step 3：评审过程度量和稳定
4. Step 4：质量意识和主人翁态度
5. Step 5：个体review的度量和稳定
6. Step 6：诉诸设计
7. Step 7：缺陷预防
8. Step 8：用户质量观——其他质量属性

#### 5.2.3.2 设计与质量的关系

1. 低劣的设计是导致在软件开发中返工、不 易维护以及用户不满的主要原因。
2. 充分设计可以显著减少最终程序的规模， 提升质量。
3. 设计本身也是一种排错的过程。

#### 5.2.3.3 PSP设计过程

![image-20211228214639645](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228213706413.png)

设计的内容![image-20211228214729239](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228215630797.png)

1. 设计目标程序在整个应用系统中的位置
2. 设计目标程序的使用方式；
3. 设计目标程序与其他组件以及模块之间的 关系；
4. 设计目标程序外部可见的变量和方法；
5. 设计目标程序内部运作机制
6. 设计目标程序内部静态逻辑；

### 5.2.4 PSP设计模板

#### 5.2.4.1 操作规格模板（Operational Specification  Template， 简称OST）

1. OST描述的是系统与外界的交互，具体而 言，是描述“用户”与待设计系统的正常情况 和异常情况下的交互
2. OST可以用来定义测试场景和测试用例， 也可以作为和系统用户讨论需求的基础， 特别是操作相关的需求描述
3. 

#### 5.2.4.2 功能规格模板（Functional Specification  Template， 简称FST）

1. FST描述的是系统对外的接口，这是一种静 态信息的描述。
2. 在FST中提供的典型信息包括类和继承关系 ，外部可见的属性和外部可见的方法等。
3. 在使用FST模板的时候，消除二义性非常重 要。因此，如果有可能，尽可能用形式化 符号来描述方法等行为

#### 5.2.4.3 状态规格模板（State Specification  Template，简称SST）

1. SST可以精确定义程序的所有的状态、状态之间 的转换以及伴随着每次状态转换的动作。
2. 在SST模板中，需要描述如下的信息：
   1. 所有状态的名称；
   2. 所有状态地简要描述
   3. 在SST中需要使用的参数和方法的名称与描述；
   4. 状态转换的条件；
   5. 状态转换是发生的动作

#### 5.2.4.4 逻辑规格模板（Logical Specification  Template，简称LST

1. LST可以精确描述系统的内部静态逻辑。为 了消除描述的二义性，一般建议用伪代码 配合形式化符号来描述设计结果。
2. 在LST模板中，需要描述如下的信息
   1. 关键方法的静态逻辑；.
   2. 方法的调用；
   3. 外部引用；
   4. 关键数据的类型和定义

#### 5.2.4.5 UML常用图

用例图，时序图，类图，状态图

#### 5.2.4.6 UML与PSP设计模板的关系

1. UML的用例图和时序图提供了与PSP中OST同样的信息；
2. UML中的时序图和类图所描述的类之间的关系以及对象之 间的交互信息在PSP4个设计模板中没有对应的内容；
3. UML类图中记录了方法的型构，然而方法的行为没有描述 ，这一点在PSP的FST中有相应的内容；
4. PSP中的LST用以描述程序的静态逻辑，这在UML没有对应 的图示方法；
5. UML中的状态图与SST描述的状态图类似，但是SST中描述 的关于状态、状态转换条件以及状态转换中的动作没有对应 的UML图示方法

#### 5.2.4.7 设计的层次

![image-20211228215630797](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228215804966.png)

##### 5.2.4.7.1 PSP模板

![image-20211228215757521](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228215757521.png)![image-20211228215804966](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220324698.png)

### 5.2.5 设计验证方法

1. 意义：简单评审不足以发现复杂缺陷
2. 方法
   1. 状态机验证 
   2. ◼ 符号化执行验证 
   3. ◼ 执行表验证 
   4. ◼ 跟踪表验证
   5.  ◼ 正确性验证

#### 5.2.5.1 状态机验证

1. 正确状态机：完整，正交
2. 验证方法
   1. 检验状态机，消除死循环和陷阱状态。
   2. ◼检查状态转换，验证完整性和正交性。
   3. 评价状态机，检验是否体现设计意图
3. 示例![image-20211228220011721](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220011721.png)
4. 复杂条件组合![image-20211228220028948](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220635174.png)

#### 5.2.5.2 符号化执行验证

1. 符号化验证方法的基本思想是将描述设计 的逻辑规格（一般用伪代码程序表示）用 代数符号来表示，然后系统地开展分析和 验证。具体步骤如下：
   1. 识别伪码程序中的关键变量；
   2. 将这些变量用代数符号表示，重写伪码程序；
   3. 分析伪码程序的行为。
2. 示例![image-20211228220324698](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220806562.png)
3. 优缺点分析
   1. 符号化验证的方法实施简单，可以给出一般 化的验证结果，很多时候往往是唯一提供全 面验证的方式。
   2. 这种方法通常用在验证一些复杂算法中，特 别是对遗留系统的改造中，往往应用这种方 法来识别和理解原有的设计。
   3. 但是这种验证方法不适用于有复杂逻辑的场 合，而且，纯手工的验证方法也容易引入一 些人为的错误

#### 5.2.5.3 执行表验证

1. 执行表用一种有序的方法来跟踪伪码程序 的执行状况，分析程序行为，从而验证设 计。具体步骤如下：
   1.  识别伪码程序的关键变量；
   2. 构建表格，表格左侧填入主要程序步骤，右侧 填入关键变量；
   3. 初始化被选定的变量；
   4. 跟踪被选择的关键变量的变化情况，从而判断 程序行为
2. 示例

![image-20211228220525733](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220028948.png)

#### 5.2.5.4 跟踪表验证

1. 跟踪表验证方法是对执行表验证方法的一种 扩充。具体步骤如下：
   1. 识别伪码程序的关键变量；
   2. 构建表格，表格左侧填入主要程序步骤，右侧填 入关键变量
   3. 初始化被选定的变量；
   4. 识别将伪码程序符号化的机会，并加以符号化；
   5. 定义并且优化用例组合；
   6. 跟踪被选择的关键变量的变化情况，从而判断程 序行为
2. 识别符号化机会![image-20211228220635174](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220525733.png)

#### 5.2.5.5 正确性检验

1. 正确性检验将伪码程序当成数学定理，采 用形式化方法加以推理和验证。这种方法 的步骤如下：
   1. 分析和识别用例；
   2. 对于复杂伪码程序的结构，应用正确性检验的 标准问题逐项加以验证；
   3. 对于不能明确判断的复杂程序结构，使用跟踪 表等辅助验证
2. 示例![image-20211228220806562](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228220811679.png)![image-20211228220811679](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228221217233.png)

# 6 团队工程开发

## 6.1 需求开发

1. 需求是一切工程活动的基础。

2. 需求类别：客户需求，产品需求，产品组件需求

3. 需求获取

   1. 客户所受到的限制也应当作为需求开发过程中需 要重点关注的内容。
   2. 通常采取所谓的需求“诱导”方式进行。
   3. “诱导”一词的含义不仅仅是普通的需求采集，它 隐含了应更加积极地、前瞻性地识别那些客户没 有明确提供的额外需求

4. 需求汇总

   1. 整理各种来源的信息，识别缺失的信息
   2. 解决冲突的需求
   3. 需求的整理和转化
   4. 推导未显式描述的需求内容

5. 需求验证

   1. 对需求进行分析和确认，以确保符合使用 者预期
   2. 典型活动包括
      1. 建立和维护操作概念和相关的场景
      2. 分析需求
      3. 确认需求

6. 需求文档制作

   1. 需求开发工作完成的一个基本标志是形成 了一份完整的、规范的、经过评审的需求 规格说明书。
   2. 需求规格说明书的编制是为了使用户和软 件开发者双方对该软件的初始规定有一个 共同的理解，使之成为整个开发工作的基 础

7. 优秀需求规格文档特征

   1. ![image-20211228221217233](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228221319166.png)

8. SRS（软件需求说明书）示例

   ![image-20211228221319166](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228221805685.png)

   

## 6.2 团队设计

1. 设计过程与PSP基本一致
2. 团队设计面向整体开发，因此需要额外考 虑如下内容：
   1. 团队智慧的使用
      1. 设计标准
         1. 命名规范
         2. 接口标准
         3. 系统出错信息
         4. 设计表示标准
      2. 两大挑战
         1. 确定整体架构之前很难进行分工
         2. 鼓励团队成员在讨论和评审会议中的参与程度
   2. 设计复用
      1. 在设计阶段必须要充分考虑复用的可能。 为了支持复用，软件项目团队需要建立一 套复用管理流程，具体而言，包括
         1. 复用接口标准
         2. 复用文档标准
         3. 复用质量保证机制
   3. 设计的可测试性支持
      1. 设计可测试性考虑主要体现在两方面：一 是要尽可能减少测试代码的数量；二是要 制作合理的测试计划
   4. 设计的可用性支持等要求
      1. 可用性的问题应当在设计阶段就开始考虑， 而不能推延到实现阶段。
      2. 针对每一个关键功能都定义操作概念和操 作场景
      3. 分析操作场景以确保软件系统开发完成之 后，系统使用者会满意。
      4. 必要时，可以邀请最终用户参与场景的评 审，使用模拟、原型等技术，更好的把握 用户真实意图
   5. 设计的文档化![image-20211228221805685](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228222504701.png)

## 6.3 实现策略

1. 评审的考虑
2. 复用策略
3. 复用策略

## 6.4 集成策略

1. 大爆炸集成策略
2. 逐一添加集成策略
3. 集簇集成策略
4. 集簇集成策略

## 6.5 验证与确认

1. 验证(Verification)和确认(Validation)都是为 了提升最终产品的质量而采取的措施。
2. 验证和确认的目的不同。
   1. 验证是目的是确保选定的工作产品与事先指定 给该工作产品的需求一致。
   2. 确认的目标则是确保开发完成的产品或者产品 组件在即将要使用该产品或者产品组件的环境 中工作正确。
3. 验证与确认活动
   1. 环境准备
   2. 对象选择
   3. 活动实施
   4. 结果分析

# 7 项目支持活动

## 7.1 配置管理

1. 基本概念
   1. 配置项
   2. 基线
2. 简介
   1. 配置管理的目的是建立与维护工作产品的 完整性
   2. 配置管理的活动![image-20211228222153425](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228222631855.png)
   3. 配置管理的对象

## 7.2 度量和分析

1. 度量与分析的意义
2. 作为项目管理支持类的活动，度量和分析活动可 以支持如下的项目管理活动
   1. 客观的估计与计划
   2. 根据建立的计划和目标，跟踪实际进展
   3. 识别与解决过程改进相关议题
   4. 提供将度量结果纳入未来其他过程的基础
3. 度量与分析活动
   1. ![image-20211228222504701](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228222153425.png)

### 7.2.1 GQM

![image-20211228222631855](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228222929622.png)

1. GQM示例-PM
   1. G: 确保稳定性、可预测性的开发过程来满 足计划的里程碑
   2. Q: 我的项目是否按照计划的轨迹前进，计 划的里程碑都能实现吗？
   3. M: 软件项目开发工作的挥发性（分支、流、 统一变更管理（UCM）活动）
2. GQM示例-DM
   1. G: 最大化所有团队贡献者的生产力。
   2. Q: 开发人员能够完成分配给他们的任务吗， 或者他们遇到障碍了吗？
   3. M: 由个体或者工作组产生的项目工件的量 级

## 7.3 决策分析

1. 意义与困难
2. 一个正式评估过程往往包含下列的活动：
   1. 建立评估备选方案的准则
   2. 识别备选解决方案
   3. 选择评估备选方案的方法
   4. 使用已建立的准则与方法，评估备选解决方案
   5. 依据评估准则，从备选方案中选择建议方案
3. 决策分析活动![image-20211228222929622](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228232815218.png)
4. 根因分析与解决方案
   1. 避免类似错误反复发生
   2. 一个正式根因分析过程往往包含下列的活动：
      1. 识别和选定问题
      2. 根因分析
      3. 建立改进的行动方案
      4. 实施改进，评估效果
   3. 典型角度：技术，人员，培训，过程![image-20211228223148910](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228232907508.png)
   4. 活动![image-20211228223027490](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228223027490.png)

# 8 定量管理
## 8.1 高成熟度项目管理

### 8.1.1 CMMI与项目管理

高成熟的项目管理，即定量管理

![image-20211228231704511](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228223148910.png)

1. 一般的项目管理
   1. 主要关心
      1. 当前状况（注意：也可 能使用数据
      2.  是否需要调整干预
   2. 但是，回答不了必须 进行预测的问题，例 如
      1. 维持现状，项目最后是 否能成功？
      2. 如果某些方面进行调整， 会有什么不同的结果？
2. 定量的项目管理
   1. 基于数据，主要关心
      1. 你对当前状态理解是否 有足够信心？
      2. **对偏差的理解**
   2. 回答如下典型问题
      1. 项目最后是否能成功？ 多大把握？是否需要预 防？
      2. 如果某些方面进行调整， 会有什么不同的结果？

### 8.1.2 实现高成熟度

1. 定量管理基本范式
   1. 构建定量模型
      1. 子过程能力基线
      2. 过程模型
   2. 应用模型
      1. 监控影响子过程的关 键因素

## 8.2 软件项目定量管理

### 8.2.1 定量管理

1. 基本概念
   1. （子）过程性能
      1. 遵循某个特定（子）过程的之后产生结果的量化描述，既 包括（子）过程度量Xi（例如，时间、缺陷消除效率、工 时等），也包括产物度量Yi（例如，缺陷密度，相应时间 等）
   2. （子）过程性能基线
      1. 上述过程性能的一个定量化的刻画，一般包括均值和范围。 通常用作过程性能的benchmark![image-20211228232815218](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228234816947.png)
   3. 过程或子过程性能模型
      1. 依据子过程的逻辑关系构建相应的数学模型，描述子过程 性能基线和整体过程有意义的性能输出（例如，质量、生 产效率、成本等）之间关系。例如 过程Yield 和 Phase Yield
2. 定量模型构建的关键实践![image-20211228232907508](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228231704511.png)

### 8.2.2 定量管理的实施

1. 定量模型应用（定量管理）的关键实践

   1. 定量管理三大目标：成本、日程、质量

   2. 建立项目定量管理目标：确定Z，需要依据原来确定的能力基线

   3. 监控被选定的子过程性能

      + XY都可以被监控，Z不行；X在更细的粒度上可以被认为是Y

   4. 构建整体过程：
      + 子过程以什么方式去做：比如质量要求较高，就需要两阶段评审；如果对质量要求不是很高，可以用较弱的评审方式（对质量要求较高的可以先使用较弱的评审方式，然后通过提高测试覆盖率等方式在其他子过程去约束质量）
      + 完全不同的子过程构建：项目型开发、产品型开发

   5. 选择关键子过程和相应属性

      + Z无法干预（比如代码每千行多少错误）
      + Y也无法干预（比如缺陷消除率）
      + 可以干预的是某些X，基本思路是如果每一个X都控制好了则Y就能符合预期，所有的Y符合预期则Z也能符合预期
      + 有时候也要打破这一界限，可以从外界选择，因为软件的可重复性很低
      + 所有的模型都是错的，但只要能用即可

   6. 监控项目性能
      + 监控Z，如果根据已有的子过程完成情况估计整体目标无法实现就需要调整过程（是否追加测试？增加测试用例密度）

      ![image-20211228233455296](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228233455296.png)

## 8.3 常用定量管理技术

### 8.3.1 非统计技术

非统计技术一般是为了描**述数据集整体特征或者关联关系**，从而帮助选择适用的 统计技术以应用于给定的数据集，以及调查通过数据分析检测到异常的原因。例 如，检查表（或列联表），帕累托图，直方图，因果图，散点图等。

#### 8.3.1.1 直方图

1. 直方图以频率统计的方式进行显示，可以描述过程属性的频率
   1. 例如缺陷修复的时间、每次测试发现的缺陷的 个数、 每天无故障工作的时间、计算产品的不合格率等
2. 一般用于
   1. 判断过程是否正常，过程能力是否满足需要，不良产品是 否发生，分析产品质量问题的原因等。

#### 8.3.1.2 帕累托图

1. 一种特殊的直方图
2. 按照由高到低排列的直方图

![image-20211228234556274](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228234644812.png)

#### 8.3.1.3 因果图

因果图是用来分析影响产品质量的各种原因的一种有效的定性的分析图，它将对 特性或结果有影响的要素加以分类分析，是一种发现问题根本原因的方法，可以 让项目组成员通过头脑风暴、集思广益的方法从各个方面各种不同的角度找出 这些问题的所有原因

![image-20211228234644812](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235136210.png)

#### 8.3.1.4 散布（点）图

整理和观察收集到的数据的常用图形工具

![image-20211228234816947](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235146193.png)

### 8.3.2 统计技术

1. 统计思维认识到许多决策是在**不确定**条件下做出的。统计 方法有助于**量化这种不确定**性并指导采取行动以减少不确 定性（非统计方法找到的规律可能是不正确的，需要进一步判断）
2. 统计分析支持许多类型的决策，在支持过程管理决策的统 计分析中，有效的过程管理通常需要两级决策 
   1. 实时控制单个活动或子流程
   2. 根据当前和已完成的活动对未来和最终过程的结果进行预测

#### 8.3.2.1 控制图

![image-20211228235136210](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235233159.png)

1. 控制图是根据概率统计原理构造的一种图，用来监测生产过程是否处于控制状态
2. 控制图是对过程质量数据测定、记录从而进行质量管理的一种用科学方法设计的图。
3. 图上有**中心线(CL)、上控制限(UCL)和下控制限(LCL)，**并有按时间顺序抽取的样本 统计量数值的描点序列
4. 控制图可由正态分布演变而来

![image-20211228235146193](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228234556274.png)

![image-20211228235233159](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235434823.png)![image-20211228235258806](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235258806.png)

两类错误：

1. Ⅰ类错误：虚发警报错误，在生产正常的情况下,纯粹出于偶然而点子出界的概 率虽然很小,但不是绝对不可能发生。故当生产正常而根据点出界判断生产异常 就犯了虚发警报错误,发生这种错误的概率通常记以α
2. Ⅱ类错误：漏发警报错误,在生产异常的情况下,产品质量的分布偏离典型分布,但 总有一部分产品的质量特性值在上下控制界之内。如果抽到这样的产品进行检测 描点,根据点未出界判断生产正常就为漏发警报错误,此概率通常记以β

![image-20211228235434823](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235442322.png)![image-20211228235442322](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228235640483.png)

#### 8.3.2.2 回归分析

![image-20211228235640483](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211228184132743.png)

### 